%NOT IN USE
function corrected_timestamps = timestamp_correction(csv_file_path)
  %from tank paper https://www.cell.com/neuron/pdfExtended/S0896-6273(18)30852-3
    %compares timestamp to expected times



      % Step 0: Load the CSV file generated by miniscope software (skip header row)
      fileID = fopen(csv_file_path, 'r');
      header_row = fgetl(fileID);  % Read and skip the header row
      fclose(fileID);

  data = dlmread(csv_file_path, ',', 1, 0);
  sysClock_ms = data(1:end, 2);
  frame_numbers = [1:1:length(sysClock_ms)]';


  % Convert system clock timestamps to seconds
  sysClock = sysClock_ms / 1000;

    % Step 1: Estimate the time per frame (eTPF)
    eTPF = median(diff(sysClock)) / median(diff(frame_numbers)); %do i want this or do i want to manually put in 1/15

    % Step 2: Predict the clock time for each frame
    predicted_clock_time = (frame_numbers - 1) * eTPF;


    % Step 3: Calculate the clock differential
    clock_differential = predicted_clock_time - sysClock;

    % Step 4: Identify frames with clock differential greater than or equal to eTPF
    lost_frames_indices = find(clock_differential >= eTPF);

    % Step 5: Determine the number of dropped frames
    num_dropped_frames = diff(lost_frames_indices)

    % Step 6: Recompute the corrected timestamps
    corrected_timestamps = sysClock;
    for i = 1:length(num_dropped_frames)
        % Correct timestamps after each lost frame
        correction = eTPF * (1:num_dropped_frames(i));
        corrected_timestamps(lost_frames_indices(i)+1:end) = corrected_timestamps(lost_frames_indices(i)+1:end) + correction;
    end

    % Plot the original and corrected timestamps for verification
    figure;
    plot(frame_numbers, sysClock, 'b.-', 'LineWidth', 1.5);
    hold on;
    plot(frame_numbers, corrected_timestamps, 'r.-', 'LineWidth', 1.5);
    xlabel('Frame Number');
    ylabel('Clock Time');
    legend('Original Timestamps', 'Corrected Timestamps');
    title('Timestamp Correction Algorithm');
    grid on;

end
