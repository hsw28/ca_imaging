%NOT IN USE
function clock_differential = timestamp_correction(csv_file_path)
  %compares timestamp intervals to expected intervals, not to expected times
  %corrected_timestamps

  % Step 0: Load the CSV file generated by miniscope software (skip header row)
  fid = fopen(csv_file_path, 'r');
  header_row = fgetl(fid);  % Read and skip the header row
  fclose(fid);

  data = dlmread(csv_file_path, ',', 1, 0);
  sysClock_ms = data(1:end, 2);
  frame_numbers = [1:1:length(sysClock_ms)]';

  % Convert system clock timestamps to seconds
  sysClock = sysClock_ms / 1000;

    % Step 1: Estimate the time per frame (eTPF)
    eTPF = 1/15;


    % Step 2: Calculate the clock differential (frame minus previous frame)
     clock_differential = sysClock(2:end)-sysClock(1:end-1);
    find(clock_differential>((1/15)*1.5));

%{
    % Step 4: Identify frames with clock differential greater than or equal to eTPF
    lost_frames_indices = find(clock_differential >= eTPF);

    % Step 5: Determine the number of dropped frames
    num_dropped_frames = diff(lost_frames_indices)

    % Step 6: Recompute the corrected timestamps
    corrected_timestamps = sysClock;
    for i = 1:length(num_dropped_frames)
        % Correct timestamps after each lost frame
        correction = eTPF * (1:num_dropped_frames(i));
        corrected_timestamps(lost_frames_indices(i)+1:end) = corrected_timestamps(lost_frames_indices(i)+1:end) + correction;
    end

    % Plot the original and corrected timestamps for verification
    figure;
    plot(frame_numbers, sysClock, 'b.-', 'LineWidth', 1.5);
    hold on;
    plot(frame_numbers, corrected_timestamps, 'r.-', 'LineWidth', 1.5);
    xlabel('Frame Number');
    ylabel('Clock Time');
    legend('Original Timestamps', 'Corrected Timestamps');
    title('Timestamp Correction Algorithm');
    grid on;

end
%}
